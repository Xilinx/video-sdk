<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->

<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="03af8d57-0a04-47a6-8f10-322fa00d8fc7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
<!-- Google Tag Manager -->
<script type="text/plain" class="optanon-category-C0002">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-5RHQV7');</script>
<!-- End Google Tag Manager -->
  <title>Managing Video Acceleration Compute Resources &mdash; Xilinx Video SDK 3.0 (Production) documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Deploying with Kubernetes" href="deploying_with_kubernetes.html" />
    <link rel="prev" title="Tuning Transcode Latency" href="tuning_pipeline_latency.html" /> 
</head>

<body class="wy-body-for-nav">

<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5RHQV7" height="0" width="0" style="display:none;visibility:hidden" class="optanon-category-C0002"></iframe></noscript>
<!-- End Google Tag Manager --> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
            <a href="index.html" class="icon icon-home"> Xilinx Video SDK
            <img src="_static/xilinx-header-logo.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="release_notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started_on_prem.html">On Premises</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started_on_vt1.html">Amazon EC2 VT1</a></li>
<li class="toctree-l1"><a class="reference internal" href="container_setup.html">Container Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Tutorials and Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Guides</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="specs_and_features.html">Specs and Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_ffmpeg.html">Using FFmpeg</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_gstreamer.html">Using GStreamer</a></li>
<li class="toctree-l1"><a class="reference internal" href="tuning_video_quality.html">Tuning Video Quality</a></li>
<li class="toctree-l1"><a class="reference internal" href="tuning_pipeline_latency.html">Tuning Transcode Latency</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Managing Compute Resources</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#assigning-jobs-to-specific-devices">Assigning Jobs to Specific Devices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#performance-considerations">Performance Considerations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples-using-explicit-device-ids">Examples using Explicit Device IDs</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#manual-resource-management">Manual Resource Management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#checking-system-load">Checking System Load</a></li>
<li class="toctree-l3"><a class="reference internal" href="#insufficient-resources">Insufficient Resources</a></li>
<li class="toctree-l3"><a class="reference internal" href="#job-resource-requirements">Job Resource Requirements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#automated-resource-management">Automated Resource Management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#video-transcode-job-descriptions">Video Transcode Job Descriptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-job-slot-reservation-tool">The Job Slot Reservation Tool</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#example-requiring-a-single-device-per-job">Example requiring a single device per job</a></li>
<li class="toctree-l4"><a class="reference internal" href="#example-requiring-two-devices-per-job">Example requiring two devices per job</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#automated-job-launching">Automated Job Launching</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-ffmpeg-launcher-example">The FFmpeg Launcher Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-gstreamer-launcher-example">The GStreamer Launcher Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#xrm-reference-guide">XRM Reference Guide</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#command-line-interface">Command Line Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#setup">Setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-status-reports">Generating Status Reports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#loading-unloading-hardware-accelerators">Loading/Unloading Hardware Accelerators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#loading-unloading-software-plugins">Loading/Unloading Software Plugins</a></li>
<li class="toctree-l4"><a class="reference internal" href="#controlling-the-xrmd-daemon">Controlling the xrmd Daemon</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-application-programming-interface">C Application Programming Interface</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="deploying_with_kubernetes.html">Deploying with Kubernetes</a></li>
<li class="toctree-l1"><a class="reference internal" href="c_apis.html">C API Programming Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="card_management.html">Card Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="package_feed.html">Package Feed Setup</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/Xilinx/video-sdk/issues">File an issue</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference external" href="https://xilinx.github.io/video-sdk/browse.html">Other versions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: black" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Xilinx Video SDK</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Managing Video Acceleration Compute Resources</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="managing-video-acceleration-compute-resources">
<h1>Managing Video Acceleration Compute Resources<a class="headerlink" href="#managing-video-acceleration-compute-resources" title="Permalink to this headline">Â¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This page describes how to manage video acceleration resources and run multiple jobs on given machine through the Xilinx Resource Manager (XRM). For information about managing multiple tasks across a cluster of machines using orchestration services (i.e Kubernetes or EKS), refer to the following page: <a class="reference internal" href="deploying_with_kubernetes.html#deploying-with-kubernetes"><span class="std std-ref">Deploying with Kubernetes</span></a>.</p>
</div>
<div class="contents local topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#introduction" id="id3">Introduction</a></p></li>
<li><p><a class="reference internal" href="#assigning-jobs-to-specific-devices" id="id4">Assigning Jobs to Specific Devices</a></p></li>
<li><p><a class="reference internal" href="#manual-resource-management" id="id5">Manual Resource Management</a></p></li>
<li><p><a class="reference internal" href="#automated-resource-management" id="id6">Automated Resource Management</a></p></li>
<li><p><a class="reference internal" href="#xrm-reference-guide" id="id7">XRM Reference Guide</a></p></li>
</ul>
</div>
<section id="introduction">
<h2><a class="toc-backref" href="#id3">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">Â¶</a></h2>
<p>Each Xilinx device on an Alveo U30 card can process an aggregate load of 4K pixels at 60 frames per second. The Xilinx Video SDK supports running multiple jobs simultaenously on a given device if the overall throughput does not exceed the limit of 4kp60. When the user has access to more than one device on a given machine, the Xilinx Video SDK also supports running one or more jobs across multiple devices. In this situation, it becomes important to manage the pool of video acceleration resources in order to get the most out of the total compute bandwidth available in the system.</p>
<p>The notion of compute units (CUs) and CU pool is central to resource managent. A typical video transcode pipeline needs a conjunction of multiple CUs like decoder, scaler, lookahead, and encoder, together forming a CU pool. Based on the input resolution and type of transcode, the load of CUs within a CU pool varies. This in turn determines how many jobs can be run real-time in parallel, and which devices has enough free resources to run a job.</p>
<p>CUs and CU ppol are managed by the XilinxÂ® FPGA resource manager (XRM). XRM is a software layer responsible for managing the hardware accelerators available in the system. XRM keeps track of total system capacity for each of the compute units (i.e. decoder, scaler, encoderâ¦), ensures capacity for a given use case and prevents over-allocation.</p>
<p>The rest of this guide explains how to:</p>
<ol class="arabic simple">
<li><p>Assign jobs to specific devices <a class="reference internal" href="#using-explicit-device-ids"><span class="std std-ref">using explicit device identifiers</span></a></p></li>
<li><p>Measure device load and determine where to run jobs using either <a class="reference internal" href="#manual-resource-management"><span class="std std-ref">manual</span></a> or <a class="reference internal" href="#using-job-descriptions"><span class="std std-ref">automated</span></a> resource management techniques</p></li>
</ol>
<p class="rubric">System Considerations</p>
<ul class="simple">
<li><p>On certain servers, it may be needed to reduce the stack size (using <code class="docutils literal notranslate"><span class="pre">ulimit</span> <span class="pre">-s</span> <span class="pre">1000</span></code>) in order to run more than 200 processes simultaneously.</p></li>
<li><p>When splitting a job across two devices, the characteristics of the host server may impact overall performance as more data transfers are generally involved in this case.</p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
<section id="assigning-jobs-to-specific-devices">
<span id="using-explicit-device-ids"></span><h2><a class="toc-backref" href="#id4">Assigning Jobs to Specific Devices</a><a class="headerlink" href="#assigning-jobs-to-specific-devices" title="Permalink to this headline">Â¶</a></h2>
<p>By default a job is submitted to device 0. When running multiple jobs in parallel, device 0 is bound to run out of resources rapidly and additional jobs will error out due to insufficient resources. By using explicit device identifiers, the different components (decoder, scaler, encoder) of a job can be individually submitted to a specific device. This makes it easy and straightforward to leverage the entire video acceleration capacity of your system, regardless of the number of cards and devices.</p>
<p>The FFmpeg <a class="reference internal" href="using_ffmpeg.html#cmdoption-lxlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-lxlnx_hwdev</span></code></a> and GStreamer <a class="reference internal" href="using_gstreamer.html#cmdoption-arg-7"><code class="xref std std-option docutils literal notranslate"><span class="pre">dev-idx</span></code></a> options can be used to specify the device on which a specific job component (decoder, scaler, encoder) should be run. This makes it possible to split a job across two devices by mapping some components of the job to one device and other components of the job to another device. This ability is useful when there are not enough compute resources to run the entire job on a single device. Typical use cases include 4K ladders or 1080p ladders with more outputs that can be scaled or encoded on a single device. When splitting a job across two devices, the video frames must be transfered from the first device to the host, and then from the host to the second device. When using FFmpeg, this transfer must be done explicitly using the <a class="reference internal" href="using_ffmpeg.html#cmdoption-arg-xvbm_convert"><code class="xref std std-option docutils literal notranslate"><span class="pre">xvbm_convert</span></code></a> filter. When using GStreamer, this transfer is handled automatically by the plugins.</p>
<p>The FFmpeg <a class="reference internal" href="using_ffmpeg.html#cmdoption-xlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-xlnx_hwdev</span></code></a> option is similar to the <a class="reference internal" href="using_ffmpeg.html#cmdoption-lxlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-lxlnx_hwdev</span></code></a> option, but it applies globally instead of locally. This option can used to specify the device on which all components of a given job should be run. The <a class="reference internal" href="using_ffmpeg.html#cmdoption-xlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-xlnx_hwdev</span></code></a> and <a class="reference internal" href="using_ffmpeg.html#cmdoption-lxlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-lxlnx_hwdev</span></code></a> options can be used together. If present, the <a class="reference internal" href="using_ffmpeg.html#cmdoption-xlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-xlnx_hwdev</span></code></a> option sets the default device index for all job components. Any subsequent <a class="reference internal" href="using_ffmpeg.html#cmdoption-lxlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-lxlnx_hwdev</span></code></a> option overwrites the device index for the particular component that it is set on.</p>
<p>Determining on which device(s) to run a job can be done using either the <a class="reference internal" href="#manual-resource-management"><span class="std std-ref">manual</span></a> or <a class="reference internal" href="#using-job-descriptions"><span class="std std-ref">automated</span></a> methods described in the following sections.</p>
<section id="performance-considerations">
<h3>Performance Considerations<a class="headerlink" href="#performance-considerations" title="Permalink to this headline">Â¶</a></h3>
<p>For higher performance, Xilinx recommends running all the different components on the same device whenever possible. Splitting a job across multiple devices leads to extra data transfers to and from the host which may impact total performance.</p>
</section>
<section id="examples-using-explicit-device-ids">
<h3>Examples using Explicit Device IDs<a class="headerlink" href="#examples-using-explicit-device-ids" title="Permalink to this headline">Â¶</a></h3>
<p class="rubric">FFmpeg example of two different jobs run on two different devices</p>
<p>In this example, two different FFmpeg jobs are run in parallel. The <a class="reference internal" href="using_ffmpeg.html#cmdoption-xlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-xlnx_hwdev</span></code></a> option is used to submit each job to a different device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ffmpeg -xlnx_hwdev 0 -c:v mpsoc_vcu_h264 -i INPUT1.h264 -f mp4 -c:v mpsoc_vcu_hevc -y /dev/null &amp;
ffmpeg -xlnx_hwdev 1 -c:v mpsoc_vcu_h264 -i INPUT2.h264 -f mp4 -c:v mpsoc_vcu_hevc -y /dev/null &amp;
</pre></div>
</div>
<p class="rubric">FFmpeg example of a 4K ladder split across two devices</p>
<p>In this example, a 4K ABR ladder with 6 outputs is split across two devices, as shown in the picture below:</p>
<figure class="align-center" id="id2">
<img alt="4K Ladder Running on Two Devices" src="_images/4k_ladder_on_two_devices.png" />
<figcaption>
<p><span class="caption-text">4K ABR ladder split across two devices</span><a class="headerlink" href="#id2" title="Permalink to this image">Â¶</a></p>
</figcaption>
</figure>
<p>This 4K ladder can be implemented in FFmpeg with the command below. The <a class="reference internal" href="using_ffmpeg.html#cmdoption-lxlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-lxlnx_hwdev</span></code></a> option is used to map each component of the FFmpeg job to the desired device. Two <a class="reference internal" href="using_ffmpeg.html#cmdoption-arg-multiscale_xma"><code class="xref std std-option docutils literal notranslate"><span class="pre">multiscale_xma</span></code></a> filters are used since there are scaling operations on both devices. The output of the scaler on device 0 is transfered back to the host with the <a class="reference internal" href="using_ffmpeg.html#cmdoption-arg-xvbm_convert"><code class="xref std std-option docutils literal notranslate"><span class="pre">xvbm_convert</span></code></a> filter. The same data is then automatically copied to the other device since it is used by the second <a class="reference internal" href="using_ffmpeg.html#cmdoption-arg-multiscale_xma"><code class="xref std std-option docutils literal notranslate"><span class="pre">multiscale_xma</span></code></a> filter:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ffmpeg -re -lxlnx_hwdev 0 -c:v mpsoc_vcu_h264 -i INPUT.h264 -max_muxing_queue_size 1024 -filter_complex &quot; \
  [0]split[a][b]; \
  [b]multiscale_xma=outputs=1:lxlnx_hwdev=0:out_1_width=1920:out_1_height=1080:out_1_rate=full [c]; [c]xvbm_convert[d]; \
  [d]multiscale_xma=outputs=4:lxlnx_hwdev=1:out_1_width=1280:out_1_height=720:out_1_rate=full: \
                                            out_2_width=848:out_2_height=480:out_2_rate=half: \
                                            out_3_width=640:out_3_height=360:out_3_rate=half: \
                                            out_4_width=288:out_4_height=160:out_4_rate=half [e][f][g][h]; \
  [e]split[i][j]; [j]fps=30[k]&quot; \
  -map &#39;[a]&#39; -lxlnx_hwdev 0 -b:v 16M   -max-bitrate 16M   -level 4.2 -slices 4 -cores 4 -c:v mpsoc_vcu_h264 -c:a copy -max_interleave_delta 0 -f mp4 -y /dev/null \
  -map &#39;[i]&#39; -lxlnx_hwdev 1 -b:v 4M    -max-bitrate 4M    -level 4.2 -c:v mpsoc_vcu_h264 -c:a copy -max_interleave_delta 0 -f mp4 -y /dev/null \
  -map &#39;[k]&#39; -lxlnx_hwdev 1 -b:v 3M    -max-bitrate 3M    -level 4.2 -c:v mpsoc_vcu_h264 -c:a copy -max_interleave_delta 0 -f mp4 -y /dev/null \
  -map &#39;[f]&#39; -lxlnx_hwdev 1 -b:v 2500K -max-bitrate 2500K -level 4.2 -c:v mpsoc_vcu_h264 -c:a copy -max_interleave_delta 0 -f mp4 -y /dev/null \
  -map &#39;[g]&#39; -lxlnx_hwdev 1 -b:v 1250K -max-bitrate 1250K -level 4.2 -c:v mpsoc_vcu_h264 -c:a copy -max_interleave_delta 0 -f mp4 -y /dev/null \
  -map &#39;[h]&#39; -lxlnx_hwdev 1 -b:v 625K  -max-bitrate 625K  -level 4.2 -c:v mpsoc_vcu_h264 -c:a copy -max_interleave_delta 0 -f mp4 -y /dev/null
</pre></div>
</div>
<p class="rubric">GStreamer example of a transcoding pipeline split across two devices</p>
<p>In this example, the <a class="reference internal" href="using_gstreamer.html#cmdoption-arg-7"><code class="xref std std-option docutils literal notranslate"><span class="pre">dev-idx</span></code></a> option is used to specify that the decoder should run on device 0 and that the encoder should run on device 1</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gst-launch-1.0 filesrc location=bbb_sunflower_1080p_60fps_normal.264 ! h264parse ! vvas_xvcudec dev-idx=0 ! queue ! vvas_xvcuenc dev-idx=1 target-bitrate=8000 max-bitrate=8000 ! video/x-h264 ! fpsdisplaysink video-sink=&quot;filesink location=/tmp/xil_xcode_out_0.mp4&quot; text-overlay=false sync=false -v
</pre></div>
</div>
<p class="rubric">GStreamer example of a 4K ladder split across two devices</p>
<p>The GStreamer equivalent of the FFmpeg example described above is shown below. It uses <a class="reference internal" href="using_gstreamer.html#cmdoption-arg-7"><code class="xref std std-option docutils literal notranslate"><span class="pre">dev-idx</span></code></a> to map each component to the desired device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>gst-launch-1.0 filesrc num-buffers=-1 location=~/videos/bbb_sunflower_2160p_60fps_normal.mp4 \
      ! qtdemux ! queue ! h264parse \
      ! vvas_xvcudec dev-idx=0 avoid-output-copy=1 \
      ! queue \
      ! tee name=dectee \
      dectee. \
              ! queue \
              ! vvas_xvcuenc name=enc_2160p60_dev0 dev-idx=0 b-frames=2 target-bitrate=16000 max-bitrate=16000 num-slices=4 num-cores=4 \
              ! queue ! h264parse ! qtmux \
              ! fpsdisplaysink name=sink_xcode_scale_2160p60_dev0_83 video-sink=&quot;filesink location=/tmp/xil_xcode_scale_2160p60_dev__0.mp4&quot; async=false text-overlay=false sync=false \
      dectee. \
              ! queue \
              ! vvas_xabrscaler dev-idx=0 ppc=4 scale-mode=2 enable-pipeline=1 avoid-output-copy=true name=sc1_0 \
              ! queue ! video/x-raw, width=1920, height=1080 \
              ! queue \
              ! tee name=sctee \
              sctee. \
                      ! queue \
                      ! vvas_xvcuenc name=enc_1080p60_dev1 dev-idx=1 target-bitrate=6000 max-bitrate=6000 \
                      ! queue ! h264parse ! qtmux \
                      ! fpsdisplaysink name=sink_xcode_scale_1080p60_dev1_83 video-sink=&quot;filesink location=/tmp/xil_xcode_scale_1080p60_dev__1.mp4&quot; async=false text-overlay=false sync=false \
              sctee. \
                      ! queue \
                      ! vvas_xabrscaler dev-idx=1 ppc=4 scale-mode=2 avoid-output-copy=true name=sc2_1 \
                      sc2_1.src_0 \
                              ! queue ! video/x-raw, width=1280, height=720 \
                              ! tee name=tee_1 \
                              tee_1. \
                                ! queue ! videorate ! video/x-raw, framerate=60/1 \
                                ! vvas_xvcuenc name=enc_720p60_dev1 dev-idx=1 target-bitrate=4000 \
                                ! queue ! h264parse ! qtmux \
                                ! fpsdisplaysink name=sink_xcode_scale_720p60_dev1_83 video-sink=&quot;filesink location=/tmp/xil_xcode_scale_720p60_dev__1.mp4&quot; async=false text-overlay=false sync=false \
                             tee_1. \
                                ! queue ! videorate ! video/x-raw, framerate=30/1 \
                                ! vvas_xvcuenc name=enc_720p30_dev1 dev-idx=1 target-bitrate=3000 \
                                ! queue ! h264parse ! qtmux \
                                ! fpsdisplaysink name=sink_xcode_scale_720p30_dev1_83 video-sink=&quot;filesink location=/tmp/xil_xcode_scale_720p30_dev__1.mp4&quot; async=false text-overlay=false sync=false \
                      sc2_1.src_1 \
                              ! queue ! video/x-raw, width=848, height=480 \
                              ! videorate ! video/x-raw, framerate=30/1 \
                              ! vvas_xvcuenc name=enc_480p30_dev1 dev-idx=1 target-bitrate=2500 \
                              ! queue ! h264parse ! qtmux \
                              ! fpsdisplaysink name=sink_xcode_scale_480p30_dev1_83 video-sink=&quot;filesink location=/tmp/xil_xcode_scale_480p30_dev__1.mp4&quot; async=false text-overlay=false sync=false \
                      sc2_1.src_2 \
                              ! queue ! video/x-raw, width=640, height=360 \
                              ! videorate ! video/x-raw, framerate=30/1 \
                              ! vvas_xvcuenc name=enc_360p30_dev1 dev-idx=1 target-bitrate=1250 \
                              ! queue ! h264parse ! qtmux \
                              ! fpsdisplaysink name=sink_xcode_scale_360p30_dev1_83 video-sink=&quot;filesink location=/tmp/xil_xcode_scale_360p30_dev__1.mp4&quot; async=false text-overlay=false sync=false \
                      sc2_1.src_3 \
                              ! queue ! video/x-raw, width=288, height=160 \
                              ! videorate ! video/x-raw, framerate=30/1 \
                              ! vvas_xvcuenc name=enc_160p30_dev1 dev-idx=1 target-bitrate=625 \
                              ! queue ! h264parse ! qtmux \
                              ! fpsdisplaysink name=sink_xcode_scale_160p30_dev1_83 video-sink=&quot;filesink location=/tmp/xil_xcode_scale_160p30_dev__1.mp4&quot; async=false text-overlay=false sync=false -v
</pre></div>
</div>
<p><strong>NOTE</strong>: Use <code class="docutils literal notranslate"><span class="pre">enable-pipeline=1</span></code> whenever there is a data copy required. In this example, on vvas_xbarscaler where data is copied from the host to the second device.</p>
<p class="rubric">Additional Examples</p>
<p>Additional examples of how to run multiple processes using explicit device IDs can be found in the tutorials included in this repository:</p>
<ul class="simple">
<li><p><a class="reference internal" href="examples/ffmpeg/tutorials.html#ffmpeg-device-id-examples"><span class="std std-ref">FFmpeg Tutorials</span></a></p></li>
<li><p><a class="reference internal" href="examples/gstreamer/tutorials.html#gstreamer-device-id-examples"><span class="std std-ref">GStreamer Tutorials</span></a></p></li>
</ul>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="manual-resource-management">
<span id="id1"></span><h2><a class="toc-backref" href="#id5">Manual Resource Management</a><a class="headerlink" href="#manual-resource-management" title="Permalink to this headline">Â¶</a></h2>
<p>The card management tools included in the Xilinx Video SDK provide ways to query the status and utilization of the compute resources on the Xilinx devices. Using these tools the user can determine which resources are available and thereby determine on which device to submit a job (using <a class="reference internal" href="#using-explicit-device-ids"><span class="std std-ref">explicit device identifies</span></a>, as explained in the previous section).</p>
<p>Given that each device has a 2160p60 (4K) input and output bandwidth limit, the user is responsible for only submitting jobs which will not exceed the capacity of the specified device. If a job is submitted on a device where there are not enough compute unit resources available to support the job, the job will error out with a message about resource allocation failure.</p>
<p>The XRM and card management tools provide methods to estimate CU requirements and check current device load.</p>
<section id="checking-system-load">
<h3>Checking System Load<a class="headerlink" href="#checking-system-load" title="Permalink to this headline">Â¶</a></h3>
<p>To check the current loading of all the devices in your system, use the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xrmadm /opt/xilinx/xrm/test/list_cmd.json
</pre></div>
</div>
<p>This will generate a report in JSON format containing the load information for all the compute unit (CU) resources. The report contains a section for each device in the system. The device sections contain sub-sections for each of the CUs (decoder, scaler, lookahead, encoder) in that device. For example, the load information for the encoder on device 0 may look as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>&quot;device_0&quot;: {
    ...
    &quot;cu_4&quot;: {
        &quot;cuId         &quot;: &quot;4&quot;,
        &quot;cuType       &quot;: &quot;IP Kernel&quot;,
        &quot;kernelName   &quot;: &quot;encoder&quot;,
        &quot;kernelAlias  &quot;: &quot;ENCODER_MPSOC&quot;,
        &quot;instanceName &quot;: &quot;encoder_1&quot;,
        &quot;cuName       &quot;: &quot;encoder:encoder_1&quot;,
        &quot;kernelPlugin &quot;: &quot;/opt/xilinx/xma_plugins/libvcu-xma-enc-plg.so&quot;,
        &quot;maxCapacity  &quot;: &quot;497664000&quot;,
        &quot;numChanInuse &quot;: &quot;20&quot;,
        &quot;usedLoad     &quot;: &quot;831472 of 1000000&quot;,
        &quot;reservedLoad &quot;: &quot;0 of 1000000&quot;,
        &quot;resrvUsedLoad&quot;: &quot;0 of 1000000&quot;
    },
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">usedLoad</span></code> value indicates how much of that resource is currently being used. The value will range from 0 (nothing running) to 1000000 (fully loaded). The <code class="docutils literal notranslate"><span class="pre">reservedLoad</span></code> value indicates how much of that resource is being reserved using XRM. The <code class="docutils literal notranslate"><span class="pre">resrvUsedLoad</span></code> value indicates how much of the reserved load is actually being used.</p>
<p>In the above example, the encoder is 83.14% utilized. An additional job may only be run on this device if it requires less than 17% of the encoder resources.</p>
</section>
<section id="insufficient-resources">
<h3>Insufficient Resources<a class="headerlink" href="#insufficient-resources" title="Permalink to this headline">Â¶</a></h3>
<p>If there are not enough compute unit resources available on the device to support a FFmpeg job, the job will error out with a message about resource allocation failure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xrm_allocation: failed to allocate decoder resources from device 0
[MPSOC HEVC decoder @ 0x562c7695b200] xrm_allocation: resource allocation failed
</pre></div>
</div>
<p>In this case, you can check the system load (as described in the section below) and look for a device with enough free resources, or wait until another job finishes and releases enough resources to run the desired job.</p>
</section>
<section id="job-resource-requirements">
<h3>Job Resource Requirements<a class="headerlink" href="#job-resource-requirements" title="Permalink to this headline">Â¶</a></h3>
<p>The load of a given job can be estimated by taking the resolution of the job as a percentage of the 2160p60 (4K) maximum. For instance, a 1080p60 stream will require 25% of the resources available on a device.</p>
<p>In addition, it is possible to run FFmpeg with the <a class="reference internal" href="using_ffmpeg.html#cmdoption-loglevel"><code class="xref std std-option docutils literal notranslate"><span class="pre">-loglevel</span></code></a> option set to <code class="docutils literal notranslate"><span class="pre">debug</span></code> to get information about the resource requirements for a given job. The messages generated in the transcript will look as follow:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>---decoder xrm out: dec_load=250000, plugin=/opt/xilinx/xma_plugins/libvcu-xma-dec-plg.so, device=0, cu=6, ch=0
---encoder xrm out: enc_load=250000, plugin=/opt/xilinx/xma_plugins/libvcu-xma-enc-plg.so, device=0, cu=38, ch=0
</pre></div>
</div>
<p>Resource loads are reported with a precision of 1/1000000. In the above example, the job requires 25% of the decoder resources and 25% of the encoder resources on the device.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>
<section id="automated-resource-management">
<span id="using-job-descriptions"></span><h2><a class="toc-backref" href="#id6">Automated Resource Management</a><a class="headerlink" href="#automated-resource-management" title="Permalink to this headline">Â¶</a></h2>
<p>The Xilinx Video SDK provides a mechanism to automatically determine how many instances of a given job can be submitted to the system and on which device(s) to dispatch each job instance. This mechanism relies on Job Descriptions files and a Job Slot Reservation tool which calculates the resources required for each job, determines on which device each job should be run and reserves the resources accordingly.</p>
<p><strong>NOTE</strong>: A current limitation of this method is that only one job description file can be used at a time, and a job description file can only contain a single job description. The system will only manage multiple jobs if they match the same description. Simultaneously managing different job types is not supported currently. The jobs need to be stopped before a new job description can be loaded.</p>
<section id="video-transcode-job-descriptions">
<span id="job-descriptions-files"></span><h3>Video Transcode Job Descriptions<a class="headerlink" href="#video-transcode-job-descriptions" title="Permalink to this headline">Â¶</a></h3>
<p>A video transcode job description provides information to the resource manager about what resources are needed to run a particular job. With this information, the resource manager can calculate the CU load for the specified job as well as the maximum possible number of jobs that can be run real-time in parallel.</p>
<p>A video transcode job description is specified through a JSON file and the key-value pairs specify the functions, formats, and resolutions needed.</p>
<dl class="simple">
<dt>function</dt><dd><p>Which HW resource to use (DECODER, SCALER, ENCODER)</p>
</dd>
<dt>format</dt><dd><p>Input/output format (H264, HEVC, yuv420p)</p>
</dd>
<dt>resolution</dt><dd><p>Input/output height, width, and frame-rate as a numerator / denominator fraction</p>
</dd>
<dt>job-count</dt><dd><p>Optional entry to specify the number of instances of the specified job which can run on one device.
When this entry is used, the CU load is calculated based on the specified job-count. Any channel-load value is ignored.
This option is useful to provide an accurate number of possible jobs in the case where the load calculation by XRM is optimistic. This can happen because device memory is currently not an XRM managed resource; and in the case of high-density low-resolution jobs, it is possible to run out device memory before running out of compute resources.</p>
</dd>
<dt>channel-load</dt><dd><p>Optional entry to specify a different compute load for a given function than calculated by the resource manager.
This option will be deprecated and removed in a future release. The job-count option should be used instead.</p>
</dd>
<dt>resources</dt><dd><p>All the resources listed in this section of the job description will be allocated on the same device. If the job requires a single device, this is the section in which resources should be specified.</p>
</dd>
<dt>additionalresources_1</dt><dd><p>Optional entry to specify the resources which need be allocated on a second device. If a job cannot fit on a single device and must be split across two devices, then the resources which should be allocated on the first device should be listed in the âresourcesâ section and the resources which should be allocated on the second device should be listed in the âadditionalresources_1â section.</p>
</dd>
</dl>
<p>Several examples of JSON job slot descriptions can be found in the <code class="docutils literal notranslate"><span class="pre">/opt/xilinx/launcher/scripts/describe_job</span></code> folder once the Xilinx Video SDK has been installed.</p>
<p>Below is the <code class="docutils literal notranslate"><span class="pre">/opt/xilinx/launcher/scripts/describe_job/describe_job_h264.json</span></code> example. This JSON example describes an ABR transcode job which uses a decoder, scaler, and encoder to generate 5 output renditions. The job-count entry is used to explicitly request 4 instances of this job per device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;request&quot;: {
        &quot;name&quot;: &quot;describe_job_h264&quot;,
        &quot;request_id&quot;: 1,
        &quot;parameters&quot;: {
            &quot;name&quot;: &quot;testjob&quot;,
            &quot;job-count&quot;: 4,
            &quot;resources&quot;: 
            [
                {
                    &quot;function&quot;: &quot;DECODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;: 1920, &quot;height&quot;: 1080, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} } }
                },
                {
                    &quot;function&quot;: &quot;SCALER&quot;,
                    &quot;format&quot;:   &quot;yuv420p&quot;,
                    &quot;resolution&quot;: 
                    {
                        &quot;input&quot;: { &quot;width&quot;: 1920, &quot;height&quot;: 1080, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} },
                        &quot;output&quot;: 
                        [
                            { &quot;width&quot;: 1280, &quot;height&quot;: 720, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} },
                            { &quot;width&quot;:  848, &quot;height&quot;: 480, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} },
                            { &quot;width&quot;:  640, &quot;height&quot;: 360, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} },
                            { &quot;width&quot;:  288, &quot;height&quot;: 160, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} }
                        ]
                    }
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;: 1280, &quot;height&quot;: 720, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} } } 
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;: 1280, &quot;height&quot;: 720, &quot;frame-rate&quot;: { &quot;num&quot;:30, &quot;den&quot;:1} } } 
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;:  848, &quot;height&quot;: 480, &quot;frame-rate&quot;: { &quot;num&quot;:30, &quot;den&quot;:1} } }  
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;:  640, &quot;height&quot;: 360, &quot;frame-rate&quot;: { &quot;num&quot;:30, &quot;den&quot;:1} } } 
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;:  288, &quot;height&quot;: 160, &quot;frame-rate&quot;: { &quot;num&quot;:30, &quot;den&quot;:1} } }  
                }
            ]
        }
    }
}
</pre></div>
</div>
<p>Below is the <code class="docutils literal notranslate"><span class="pre">/opt/xilinx/launcher/scripts/describe_job/testjob_4k_2dev.json</span></code> example. This JSON example describes a 4K ABR transcode job split across two devices and generating 6 output renditions. The resources allocated on the first device are listed in the âresourcesâ section and the resources allocated on the second device are listed in the âadditionalresources_1â section. This job corresponds to the one pictured above in the <a class="reference internal" href="#using-explicit-device-ids"><span class="std std-ref">Using Explicit Device IDs</span></a> topic.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;request&quot;: {
        &quot;name&quot;: &quot;testjob_4k_2dev&quot;,
        &quot;request_id&quot;: 1,
        &quot;parameters&quot;: {
            &quot;name&quot;: &quot;testjob&quot;,
            &quot;resources&quot;: 
            [
                {
                    &quot;function&quot;: &quot;DECODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;: 3840, &quot;height&quot;: 2160, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} } }
                },
                {
                    &quot;function&quot;: &quot;SCALER&quot;,
                    &quot;format&quot;:   &quot;yuv420p&quot;,
                    &quot;resolution&quot;:
                    {
                        &quot;input&quot;: { &quot;width&quot;: 3840, &quot;height&quot;: 2160, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} },
                        &quot;output&quot;:
                        [
                            { &quot;width&quot;: 1920, &quot;height&quot;: 1080, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} }
                        ]
                    }
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;:  3840, &quot;height&quot;: 2160, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} } }
                }
            ],
            &quot;additionalresources_1&quot;:
            [
                {
                    &quot;function&quot;: &quot;SCALER&quot;,
                    &quot;format&quot;:   &quot;yuv420p&quot;,
                    &quot;resolution&quot;: 
                    {
                        &quot;input&quot;: { &quot;width&quot;: 1920, &quot;height&quot;: 1080, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} },
                        &quot;output&quot;: 
                        [
                            { &quot;width&quot;: 1280, &quot;height&quot;: 720, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} },
                            { &quot;width&quot;:  848, &quot;height&quot;: 480, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} },
                            { &quot;width&quot;:  640, &quot;height&quot;: 360, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} },
                            { &quot;width&quot;:  288, &quot;height&quot;: 160, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} }
                        ]
                    }
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;: 1280, &quot;height&quot;: 720, &quot;frame-rate&quot;: { &quot;num&quot;:60, &quot;den&quot;:1} } } 
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;: 1280, &quot;height&quot;: 720, &quot;frame-rate&quot;: { &quot;num&quot;:30, &quot;den&quot;:1} } } 
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;:  848, &quot;height&quot;: 480, &quot;frame-rate&quot;: { &quot;num&quot;:30, &quot;den&quot;:1} } }  
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;:  640, &quot;height&quot;: 360, &quot;frame-rate&quot;: { &quot;num&quot;:30, &quot;den&quot;:1} } } 
                },
                {
                    &quot;function&quot;: &quot;ENCODER&quot;,
                    &quot;format&quot;:   &quot;H264&quot;,
                    &quot;resolution&quot;: { &quot;input&quot;: { &quot;width&quot;:  288, &quot;height&quot;: 160, &quot;frame-rate&quot;: { &quot;num&quot;:30, &quot;den&quot;:1} } }  
                }
            ]
        }
    }
}
</pre></div>
</div>
<p>The next sections document the two different ways of using job descriptions to run multiple jobs across one or more devices:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#using-job-slot-reservations"><span class="std std-ref">Using the job slot reservation tool</span></a></p></li>
<li><p>Automated job launcher examples for <a class="reference internal" href="#using-ffmpeg-launcher"><span class="std std-ref">FFmpeg</span></a> and <a class="reference internal" href="#using-gstreamer-launcher"><span class="std std-ref">GStreamer</span></a></p></li>
</ul>
</section>
<section id="the-job-slot-reservation-tool">
<span id="using-job-slot-reservations"></span><h3>The Job Slot Reservation Tool<a class="headerlink" href="#the-job-slot-reservation-tool" title="Permalink to this headline">Â¶</a></h3>
<p>The job slot reservation application takes as input a <a class="reference internal" href="#job-descriptions-files"><span class="std std-ref">JSON job description</span></a>. The JSON job description file provides information to the resource manager about what kind of transcode is intended to run on the card. With this information the resource manager calculates the CU load for the specified job as well as the maximum possible number of jobs that can be run real-time in parallel.</p>
<p>Once the maximum possible number of jobs is known, CUs and job slots are reserved, and corresponding reservation IDs are stored in a bash file at <code class="docutils literal notranslate"><span class="pre">/var/tmp/xilinx/xrm_jobReservation.sh</span></code>. A reservation ID is a unique identifier which is valid while the job slot reservation application is running. These reservation IDs are passed to individual FFmpeg or GStreamer processes via the <span class="target" id="index-0"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">XRM_RESERVE_ID</span></code> environment variable. The FFmpeg or GStreamer processes then use this reservation ID to retrieve and use the corresponding CUs reserved by the job slot reservation tool.</p>
<p>If the job is split across two devices (by declaring an âadditionalresources_1â section in the JSON job description), the <code class="docutils literal notranslate"><span class="pre">xrm_jobReservation.sh</span></code> file will also declare additional identifier for each of the two devices used by the job. These identifiers should be used with the <a class="reference internal" href="using_ffmpeg.html#cmdoption-lxlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-lxlnx_hwdev</span></code></a> FFmpeg option or the <a class="reference internal" href="using_gstreamer.html#cmdoption-arg-7"><code class="xref std std-option docutils literal notranslate"><span class="pre">dev-idx</span></code></a> GStreamer option in when running the process.</p>
<p>The reserved resourced are released by ending the job reservation process. Reserved slots can be reused after an FFmpeg or GStreamer job finishes as long as the job reservation process is still running.</p>
<p>The <a class="reference external" href="https://github.com/Xilinx/app-jobslot-reservation-xrm/blob/U30_GA_2/jobSlot_reservation.cpp">source code of the job slot reservation application</a> is included in the Github repository of Xilinx Video SDK and can be used as a starting point for developing custom orchestration layers.</p>
<p class="rubric">Ill-formed JSON Job Descriptions</p>
<p>If you run the <strong class="program">jobSlotReservation</strong> tool with a syntactically incorrect JSON description, you will see the following messages:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>decoder plugin function=0 fail to run the function
scaler plugin function=0 fail to run the function
encoder plugin function=0 fail to run the function
</pre></div>
</div>
<p>This indicates that the job description is ill-formed and needs to be corrected.</p>
<section id="example-requiring-a-single-device-per-job">
<h4>Example requiring a single device per job<a class="headerlink" href="#example-requiring-a-single-device-per-job" title="Permalink to this headline">Â¶</a></h4>
<p>This example uses the <code class="docutils literal notranslate"><span class="pre">/opt/xilinx/launcher/scripts/describe_job/describe_job.json</span></code> file describing a 1080p ABR ladder running on a single device.</p>
<ol class="arabic">
<li><p>Setup the environment:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>source /opt/xilinx/xcdr/setup.sh
</pre></div>
</div>
</li>
<li><p>Run the job slot reservation application with the desired JSON job description. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>jobSlotReservation /opt/xilinx/launcher/scripts/describe_job/describe_job.json

For describe_job.json, the possible number of job slots available = 8
--------------------------------------------------------------------------------------
The Job_slot_reservations are alive as long as this application is alive!
(press Enter to end)
--------------------------------------------------------------------------------------
</pre></div>
</div>
<p>The job slot reservation application creates a <code class="docutils literal notranslate"><span class="pre">/var/tmp/xilinx/xrm_jobReservation.sh</span></code> with <span class="target" id="index-1"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">XRM_RESERVE_ID_{n}</span></code> set to unique IDs generated by XRM (with n ranging from 1 to the number of possible job slots for the given job). Here is an example of this generated file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>export XRM_RESERVE_ID_1=9
export XRM_RESERVE_ID_2=10
export XRM_RESERVE_ID_3=11
export XRM_RESERVE_ID_4=12
export XRM_RESERVE_ID_5=13
export XRM_RESERVE_ID_6=14
export XRM_RESERVE_ID_7=15
export XRM_RESERVE_ID_8=16
</pre></div>
</div>
</li>
<li><p>Launch individual FFmpeg processes in distinct shells after sourcing the <code class="docutils literal notranslate"><span class="pre">/var/tmp/xilinx/xrm_jobReservation.sh</span></code> file and setting <span class="target" id="index-2"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">XRM_RESERVE_ID</span></code> environment to a unique <span class="target" id="index-3"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">XRM_RESERVE_ID_{n}</span></code>.</p>
<p>For job 1, within a new terminal:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>source /var/tmp/xilinx/xrm_jobReservation.sh
export XRM_RESERVE_ID=${XRM_RESERVE_ID_1}
ffmpeg -c:v mpsoc_vcu_h264 ...
</pre></div>
</div>
<p>For job 2, within a new terminal:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>source /var/tmp/xilinx/xrm_jobReservation.sh
export XRM_RESERVE_ID=${XRM_RESERVE_ID_2}
ffmpeg -c:v mpsoc_vcu_h264 ...
</pre></div>
</div>
<p>And so forth for the other jobs.</p>
</li>
<li><p>Press <strong>Enter</strong> in the job reservation app terminal to release the resources after the jobs are complete.</p></li>
</ol>
</section>
<section id="example-requiring-two-devices-per-job">
<h4>Example requiring two devices per job<a class="headerlink" href="#example-requiring-two-devices-per-job" title="Permalink to this headline">Â¶</a></h4>
<p>This example uses the <code class="docutils literal notranslate"><span class="pre">/opt/xilinx/launcher/scripts/describe_job/testjob_4k_2dev.json</span></code> file describing a 4K ABR ladder split across two devices.</p>
<ol class="arabic">
<li><p>Setup the environment:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>source /opt/xilinx/xcdr/setup.sh
</pre></div>
</div>
</li>
<li><p>Run the job slot reservation application with the desired JSON job description. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>jobSlotReservation /opt/xilinx/launcher/scripts/describe_job/testjob_4k_2dev.json

For describe_job.json, the possible number of job slots available = 2
--------------------------------------------------------------------------------------
The Job_slot_reservations are alive as long as this application is alive!
(press Enter to end)
--------------------------------------------------------------------------------------
</pre></div>
</div>
<p>The job slot reservation application creates a <code class="docutils literal notranslate"><span class="pre">/var/tmp/xilinx/xrm_jobReservation.sh</span></code> with XRM_RESERVE_ID_{n} set to unique IDs generated by XRM (with n ranging from 1 to the number of possible job slots for the given job). The file also sets <span class="target" id="index-4"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">var_dev_{n}_0</span></code> and <span class="target" id="index-5"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">var_dev_{n}_1</span></code> variables indicating, for each job {n}, the identifiers of the two devices which should be used. Here is an example of this generated file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>export XRM_RESERVE_ID_1=3
var_dev_1_0=0
var_dev_1_1=1

export XRM_RESERVE_ID_2=4
var_dev_2_0=2
var_dev_2_1=1
</pre></div>
</div>
</li>
<li><p>Launch individual FFmpeg processes in distinct shells after sourcing the <code class="docutils literal notranslate"><span class="pre">/var/tmp/xilinx/xrm_jobReservation.sh</span></code> file and setting <span class="target" id="index-6"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">XRM_RESERVE_ID</span></code> environment to a unique <span class="target" id="index-7"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">XRM_RESERVE_ID_{n}</span></code>. The use <span class="target" id="index-8"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">$var_dev_{n}_0</span></code> and <span class="target" id="index-9"></span><code class="xref std std-envvar docutils literal notranslate"><span class="pre">$var_dev_{n}_1</span></code> as values for the <a class="reference internal" href="using_ffmpeg.html#cmdoption-lxlnx_hwdev"><code class="xref std std-option docutils literal notranslate"><span class="pre">-lxlnx_hwdev</span></code></a> options on the FFmpeg command line.</p>
<p>For job 1, within a new terminal:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>source /var/tmp/xilinx/xrm_jobReservation.sh
export XRM_RESERVE_ID=${XRM_RESERVE_ID_1}
ffmpeg -lxlnx_hwdev ${var_dev_1_0} -c:v mpsoc_vcu_h264 ... -lxlnx_hwdev ${var_dev_1_1} -c:v mpsoc_vcu_h264 -f mp4  ...
</pre></div>
</div>
<p>For job 2, within a new terminal:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>source /var/tmp/xilinx/xrm_jobReservation.sh
export XRM_RESERVE_ID=${XRM_RESERVE_ID_2}
ffmpeg -lxlnx_hwdev ${var_dev_2_0} -c:v mpsoc_vcu_h264 ... -lxlnx_hwdev ${var_dev_2_1} -c:v mpsoc_vcu_h264 -f mp4  ...
</pre></div>
</div>
<p>And so forth for the other jobs.</p>
</li>
<li><p>Press <strong>Enter</strong> in the job reservation app terminal to release the resources after the jobs are complete.</p></li>
</ol>
</section>
</section>
<section id="automated-job-launching">
<span id="launcher-examples"></span><h3>Automated Job Launching<a class="headerlink" href="#automated-job-launching" title="Permalink to this headline">Â¶</a></h3>
<p>The Job Slot Reservation tool automatically reserves job slots, but actual jobs still need to be manually launched using the generated reservations IDs. It is possible to create custom orchestration layers to automatically handle the reservation of job slots and the launching of jobs.</p>
<p>The Xilinx Video SDK includes two examples of âlauncherâ applications for FFmpeg and GStreamer, respectively. Source code for the FFmpeg Launcher example, the GStreamer Launcher and the Job Slot Reservation tool are included in the Github repository of Xilinx Video SDK and can be used as a starting point for developing custom orchestration layers.</p>
<section id="the-ffmpeg-launcher-example">
<span id="using-ffmpeg-launcher"></span><h4>The FFmpeg Launcher Example<a class="headerlink" href="#the-ffmpeg-launcher-example" title="Permalink to this headline">Â¶</a></h4>
<p>The FFmpeg launcher is an example application which automates the dispatching of FFmpeg jobs across multiple devices. It simplifies the process of manually setting up XRM reservation IDs and launching FFmpeg for many video streams. The FFmpeg launcher takes a transcode job description, input source files, corresponding FFmpeg run commands and automatically launches child FFmpeg processes based on the job slot availability on the server. In case there are more input streams listed than available job slots, the excess are queued and launched when a job slot becomes available. Note that only a single launcher per server is supported.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The FFmpeg launcher is only an example application. It is provided as an illustration of how an orchestration layer can use Job Descriptions, but it is not an official feature of the Xilinx Video SDK.</p>
</div>
<p>The following steps show how to use the FFmpeg launcher for an ABR transcode use case with the Xilinx Video SDK. In this use case, one encoded stream is transcoded to five unique renditions based on resolution, bit rate, and other variations.</p>
<ol class="arabic">
<li><p>Environment setup</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>source /opt/xilinx/xcdr/setup.sh
</pre></div>
</div>
</li>
<li><p>To run the FFmpeg launcher, use the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>launcher &lt;source files file name&gt; &lt;run params file name&gt;
</pre></div>
</div>
<p>Here is an example of the command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>launcher sources.txt /opt/xilinx/launcher/scripts/run_params/Run_ABR_h264_lowLatencyTranscode_mr_null.txt
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sources.txt</span></code> is a text file that lists the input stream names. The launcher parses this list and inserts the sources in the FFmpeg command after <code class="docutils literal notranslate"><span class="pre">-i</span></code> one after another and launches them as a separate process. A sample <code class="docutils literal notranslate"><span class="pre">sources.txt</span></code> is as follows.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># List all sources here
Input1.mp4
Video.flv
Input2.h264
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">run_params.txt</span></code> is a text file that consists of two fields. The first field is the video transcode job description, and the second field is the FFmpeg command line that needs to be launched and is matching the described job. Description of the job is given through a json file as described already in the previous sections. A sample <code class="docutils literal notranslate"><span class="pre">run_params.txt</span></code> is as follows.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>job_description = /opt/xilinx/launcher/scripts/describe_job/describe_job.json
cmdline = ffmpeg -c:v mpsoc_vcu_h264 -i -filter_complex &quot;multiscale_xma=:outputs=4:out_1_width=1280:out_1_height=720:out_1_pix_fm t=vcu_nv12:out_2_width=848:out_2_height=480:out_2_pix_fmt=vcu_nv12:out_3_ width=640:out_3_height=360:out_3_pix_fmt=vcu_nv12:out_4_width=288:out_4_h eight=160:out_4_pix_fmt=vcu_nv12 [a][b][c][d]; [a]split[aa][ab]&quot; -map &#39;[aa]&#39; -b:v 4M -max-bitrate 4M -c:v mpsoc_vcu_h264 -f h264 -y out_720p60.264 -map &#39;[ab]&#39; -r 30 -b:v 3M -max-bitrate 3M -c:v mpsoc_vcu_h264 -f h264 -y out_720p30.264 -map &#39;[b]&#39; -r 30 -b:v 2500K - max-bitrate 2500K -c:v mpsoc_vcu_h264 -f h264 -y out_480p30.264 -map &#39;[c]&#39; -r 30 -b:v 1250K -max-bitrate 1250K -c:v mpsoc_vcu_h264 -f h264 -y out_360p30.264 -map &#39;[d]&#39; -r 30 -b:v 625K -max-bitrate 625K -c:v mpsoc_vcu_h264 -f h264 -y out_160p30.264
</pre></div>
</div>
</li>
</ol>
</section>
<section id="the-gstreamer-launcher-example">
<span id="using-gstreamer-launcher"></span><h4>The GStreamer Launcher Example<a class="headerlink" href="#the-gstreamer-launcher-example" title="Permalink to this headline">Â¶</a></h4>
<p>The GStreamer launcher is an example application which automates the dispatching of GStreamer jobs across multiple devices. It simplifies the process of manually setting up XRM reservation IDs and launching GStreamer for many video streams. The GStreamer launcher takes a transcode job description, input source files, corresponding GStreamer run commands and automatically launches child GStreamer processes based on the job slot availability on the server. In case there are more input streams listed than available job slots, the excess are queued and launched when a job slot becomes available. Note that only a single launcher per server is supported.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The GStreamer launcher is only an example application. It is provided as an illustration of how an orchestration layer can use Job Descriptions, but it is not an official feature of the Xilinx Video SDK.</p>
</div>
<p>The following steps show how to use the GStreamer launcher for an ABR transcode use case with the Xilinx Video SDK. In this use case, one encoded stream is transcoded to five unique renditions based on resolution, bit rate, and other variations.</p>
<ol class="arabic">
<li><p>Environment setup</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>source /opt/xilinx/xcdr/setup.sh
</pre></div>
</div>
</li>
<li><p>To run the GStreamer launcher, use the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>launcher &lt;source files file name&gt; &lt;run params file name&gt;
</pre></div>
</div>
<p>Here is an example of the command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>launcher sources.txt /opt/xilinx/launcher/scripts/vvas_run_params/Run_1080p60_ABR_h264_lowLatencyTranscode_mr_null.txt
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">sources.txt</span></code> is a text file that lists the input stream names. The launcher parses this list and inserts the sources in the GStreamer command one after another and launches them as a separate process. A sample <code class="docutils literal notranslate"><span class="pre">sources.txt</span></code> is as follows.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># List all sources here
Input1.mp4
Video.flv
Input2.h264
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">run_params.txt</span></code> is a text file that consists of two fields. The first field is the video transcode job description, and the second field is the GStreamer command line that needs to be launched and is matching the described job. Description of the job is given through a json file as described already in the previous sections. A sample <code class="docutils literal notranslate"><span class="pre">run_params.txt</span></code> is as follows.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>job_description = /opt/xilinx/launcher/scripts/describe_job/describe_job.json
cmdline = gst-launch-1.0 filesrc ! h264parse ! vvas_xvcudec num-entropy-buf=2 ! queue max-size-buffers=1   ! vvas_xabrscaler kernel-name=&quot;scaler:scaler_1&quot; scale-mode=2 name=sc sc.src_0 ! queue max-size-buffers=1   ! video/x-raw, width=1280, height=720, format=NV12 ! queue max-size-buffers=1   ! tee name=t t. ! queue max-size-buffers=1   ! videorate ! video/x-raw, framerate=60/1 ! vvas_xvcuenc target-bitrate=4000 max-bitrate=4000 ! h264parse ! video/x-h264, profile=high, level=(string)4.2 ! fpsdisplaysink name=sink_720p60 video-sink=&quot;fakesink async=false&quot; text-overlay=false fps-update-interval=5000 sync=false t. ! queue max-size-buffers=1   ! videorate ! video/x-raw, width=1280, height=720, framerate=30/1 ! vvas_xvcuenc target-bitrate=3000 max-bitrate=3000 ! h264parse ! video/x-h264, profile=high, level=(string)4.2 ! fpsdisplaysink name=sink_720p30 video-sink=&quot;fakesink async=false&quot; text-overlay=false fps-update-interval=5000 sync=false sc.src_1 ! queue max-size-buffers=1   ! video/x-raw, width=848, height=480, format=NV12 ! videorate ! video/x-raw, framerate=30/1 ! vvas_xvcuenc target-bitrate=2500 max-bitrate=2500 ! h264parse ! video/x-h264, profile=high, level=(string)4.2 ! fpsdisplaysink name=sink_480p30 video-sink=&quot;fakesink async=false&quot; text-overlay=false fps-update-interval=5000 sync=false sc.src_2 ! queue max-size-buffers=1   ! video/x-raw, width=640, height=360, format=NV12 ! videorate ! video/x-raw, framerate=30/1 ! vvas_xvcuenc target-bitrate=1250 max-bitrate=1250 ! h264parse ! video/x-h264, profile=high, level=(string)4.2 ! fpsdisplaysink name=sink_360p30 video-sink=&quot;fakesink async=false&quot; text-overlay=false fps-update-interval=5000 sync=false sc.src_3 ! queue max-size-buffers=1   ! video/x-raw, width=288, height=160, format=NV12 ! videorate ! video/x-raw, framerate=30/1 ! vvas_xvcuenc target-bitrate=625 max-bitrate=625 ! h264parse ! video/x-h264, profile=high, level=(string)4.2 ! fpsdisplaysink name=sink_160p30 video-sink=&quot;fakesink async=false&quot; text-overlay=false fps-update-interval=5000 sync=false -v
</pre></div>
</div>
</li>
</ol>
<div class="line-block">
<div class="line"><br /></div>
</div>
</section>
</section>
</section>
<section id="xrm-reference-guide">
<span id="xrmadm-and-xrmd-commands"></span><span id="xrm-reference"></span><h2><a class="toc-backref" href="#id7">XRM Reference Guide</a><a class="headerlink" href="#xrm-reference-guide" title="Permalink to this headline">Â¶</a></h2>
<p>The XilinxÂ® FPGA resource manager (XRM) is the software which manages the hardware accelerators available in the system. XRM includes the following components:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xrmd</span></code>: the XRM daemon, a background process supporting reservation, allocation, and release of hardware acceleration resources.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">xrmadm</span></code> the command line tool is used to interact with the XRM daemon (<code class="docutils literal notranslate"><span class="pre">xrmd</span></code>).</p></li>
<li><p>a C Application Programming Interface (API)</p></li>
</ul>
<section id="command-line-interface">
<h3>Command Line Interface<a class="headerlink" href="#command-line-interface" title="Permalink to this headline">Â¶</a></h3>
<p>The XRM <code class="docutils literal notranslate"><span class="pre">xrmadm</span></code> command line tool is used to interact with the XRM daemon (<code class="docutils literal notranslate"><span class="pre">xrmd</span></code>). It provides the following capabilities and uses a JSON file as input for each action:</p>
<ul class="simple">
<li><p>Generate status reports for each device</p></li>
<li><p>Load and unload the hardware accelerators</p></li>
<li><p>Load and unload the software plugins</p></li>
</ul>
<p>The XRM related files are installed under <code class="docutils literal notranslate"><span class="pre">/opt/xilinx/xrm/</span></code> and device-specific XRM commands are available at <code class="docutils literal notranslate"><span class="pre">/opt/xilinx/xcdr/scripts/xrm_commands/</span></code>.</p>
<section id="setup">
<h4>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">Â¶</a></h4>
<p>When sourced, the <code class="docutils literal notranslate"><span class="pre">/opt/xilinx/xcdr/setup.sh</span></code> script takes care of setting up the enviroment for the Xilinx Video SDK, including its XRM components:</p>
<ul class="simple">
<li><p>The XRM daemon (<code class="docutils literal notranslate"><span class="pre">xrmd</span></code>) is started</p></li>
<li><p>The hardware accelerators (xclbin) and software plugins are loaded on the Xilinx devices</p></li>
</ul>
</section>
<section id="generating-status-reports">
<h4>Generating Status Reports<a class="headerlink" href="#generating-status-reports" title="Permalink to this headline">Â¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">xrmadm</span></code> can generate reports with the status of each device in the system. This capability is particularly useful to check the loading of each hardware accelerator.</p>
<p>To generate a report for all the devices in the system:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xrmadm /opt/xilinx/xrm/test/list_cmd.json
</pre></div>
</div>
<p>To generate a report for a single device specified in the json file:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xrmadm /opt/xilinx/xrm/test/list_onedevice.json
</pre></div>
</div>
<p>A sample JSON file for generating a report for device 0 is shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;request&quot;: {
        &quot;name&quot;: &quot;list&quot;,
        &quot;requestId&quot;: 1,
        &quot;device&quot;: 0
    }
}
</pre></div>
</div>
</section>
<section id="loading-unloading-hardware-accelerators">
<h4>Loading/Unloading Hardware Accelerators<a class="headerlink" href="#loading-unloading-hardware-accelerators" title="Permalink to this headline">Â¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">xrmadm</span></code> can be used to load or unload the hardware accelerators on the programmable devices of the Alveo U30 card. The hardware accelerators must be reloaded after rebooting a card.</p>
<p>To load the hardware accelerators on a given device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xrmadm /opt/xilinx/xcdr/scripts/xrm_commands/load_multiple_devices/load_device0_cmd.json
</pre></div>
</div>
<p>To unload the hardware accelerators from a given device:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xrmadm /opt/xilinx/xcdr/scripts/xrm_commands/unload_multiple_devices/unload_device_0_cmd.json
</pre></div>
</div>
<p>A sample JSON file for loading two devices (0 and 1) is shown below:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>{
    &quot;request&quot;: {
        &quot;name&quot;: &quot;load&quot;,
        &quot;requestId&quot;: 1,
        &quot;parameters&quot;: [
            {
            &quot;device&quot;: 0,
            &quot;xclbin&quot;: &quot;/opt/xilinx/xcdr/xclbins/transcode.xclbin&quot;
            },
            {
            &quot;device&quot;: 1,
            &quot;xclbin&quot;: &quot;/opt/xilinx/xcdr/xclbins/transcode.xclbin&quot;
            }
        ]
    }
}
</pre></div>
</div>
</section>
<section id="loading-unloading-software-plugins">
<h4>Loading/Unloading Software Plugins<a class="headerlink" href="#loading-unloading-software-plugins" title="Permalink to this headline">Â¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">xrmadm</span></code> can be used to load or unload the software plugins required to manage the compute resources. The software plugins perform resource management functions such as calculating CU load and CU max capacity. Once a plugin is loaded, it becomes usable by a host application through the XRM APIs. The XRM plugins need to be loaded before executing an application (such as FFmpeg/GStreamer) which relies on the plugins.</p>
<p>To load the plugins:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xrmadm /opt/xilinx/xcdr/scripts/xrm_commands/load_multi_u30_xrm_plugins_cmd.json
</pre></div>
</div>
<p>To unload the plugins:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>xrmadm /opt/xilinx/xcdr/scripts/xrm_commands/unload_multi_u30_xrm_plugins_cmd.json
</pre></div>
</div>
</section>
<section id="controlling-the-xrmd-daemon">
<h4>Controlling the xrmd Daemon<a class="headerlink" href="#controlling-the-xrmd-daemon" title="Permalink to this headline">Â¶</a></h4>
<p>The following commands can be used to start, stop, restart, or get the status of the daemon:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>sudo /opt/xilinx/xrm/tools/start_xrmd.sh
sudo /opt/xilinx/xrm/tools/stop_xrmd.sh
sudo /opt/xilinx/xrm/tools/restart_xrmd.sh
sudo systemctl status xrmd
</pre></div>
</div>
</section>
</section>
<section id="c-application-programming-interface">
<h3>C Application Programming Interface<a class="headerlink" href="#c-application-programming-interface" title="Permalink to this headline">Â¶</a></h3>
<p>XRM provides a C Application Programming Interface (API) to reserve, allocate and release CUs from within a custom application. For complete details about this programming interface, refer to the <a class="reference internal" href="c_apis.html#xrm-api-reference"><span class="std std-ref">XRM API Reference Guide</span></a> section of the documentation.</p>
</section>
</section>
</section>


           </div>
          </div>
          
				  
				  <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tuning_pipeline_latency.html" class="btn btn-neutral float-left" title="Tuning Transcode Latency" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="deploying_with_kubernetes.html" class="btn btn-neutral float-right" title="Deploying with Kubernetes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2023, Advanced Micro Devices, Inc.
      <span class="lastupdated">Last updated on August 28, 2023.
      </span></p>
  </div>



										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">

													                    <div class="row">
                        <div class="col-xs-24">
                          <p><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a> | <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a> | <a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a> | <a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a> | <a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a> | <a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a> | <a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></p>
                        </div>
                    </div>
												</div>
											</div>
										</div>
										
</br>


  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>